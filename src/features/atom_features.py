'''
AHAAB atom_features submodule
Part of the AHAAB features module

ahaab/
└──features
    └──atom_features.py

Submodule list:

    atom_hbonds
    atom_hydrophobic
    atom_electrostatic
    atom_VdW
    atom_pipi
    atom_catpi

Variables:

    bin_default
    > Contains default distance bin values for creating discretized distances
    scope_default
    > "res" or "pep"; calculates features for each residue ("res") or over
      the entire peptide ("pep")
'''
# AHAAB import
from tools import formats

# rdkit
from rdkit.Chem import rdForceFieldHelpers

# Pandas
import pandas as pd

# numpy
import numpy as np

bin_default={
    "bin_min":0,
    "bin_max":5,
    "bin_size":0.5
}

scope_default={
    "interface_scope":"res"
}

def atom_hbonds(**kwargs):
    '''
    Usage:
    $ atom_hbonds(**kwargs)

    Keyword arguments:
    > pep_feat: rdkit feature object for the peptide
    > pep_mol:  rdkit mol object for the peptide
    > hla_feat: rdkit feature object for the HLA
    > hla_mol:  rdkit mol object for the hla
    > xyz_mol:  pandas dataframe with atomic 
                coordinates
    > all_atom_dist: all-atom distance matrix in
                pandas dataframe, generated by
                tools.utils.get_distance_matrix
    > bin_min:  Minimum distance to calculate
                feature in angstroms
    > bin_max:  Maximum distance to calculate
                feature in angstroms
    > bin_size: Size in angstroms of distance 
                bins
    > resnum:   Flag corresponding to 'interface
                scope' value in feature generation.
                If set to 'all', will sum features at
                discretized distances across all
                residues. Otherwise will be set to
                a list of residue numbers for which
                featurization will be performed
                independently
    > get_metadata: Flag indicating metadata should
                    be retrieved [LEGACY]
    > rdkit_mol: rdkit mol object for the peptide/hla
                complex
    > to_print: whether or not the standard progress
                messaging for this function should
                print to the screen (set to False
                when multitasking to avoid spamming
                the standard output)
    
    Note: bins are determined [bin_min,bind_max)

    Outputs:
    > Dataframe with h-bond feature counts and 
      calculation details.
      
      Feature column naming convention:
      <hbond_pep_donor_hla_acceptor_res{x}_bin{y}>
      and
      <hbond_pep_acceptor_hla_donor_res{x}_bin{y}>

      res{x}: x is the residue number from N to 
      C terminus (1 to N, where N is the total 
      number of residues in the peptide). This
      suffix is omitted if the user opts to sum
      features over the entire peptide (interface
      scope set to "pep").

      bin{y}: y is the discretized distance bin 
      number.
    '''
    # Hydrogen bond identification works under the operating principle of 'how many hydrogen bonds *could* a given donor/acceptor atom create' in a given distance bin, and counts these potential bonds. It does not attempt to make actual pairings. It does not include or exclude bonds based on angle or distance. Approach:
        # Identify all donor and acceptors
        # Iterate through distance bins. For each peptide h-bond donor, identify all HLA h-bond acceptors in that bin.
        # Pair each donor with all available receptors, within the distance bin.
        # Pair each acceptor with all available donors, within the distnace bin.

    # Define our standard keyword arguments used for all atom_features methods (arguments not used by this method are commented out)
    pep_feat=kwargs["pep_feat"]
    pep_mol=kwargs["pep_mol"]
    hla_feat=kwargs["hla_feat"]
    hla_mol=kwargs["hla_mol"]
    # xyz_mol=kwargs["xyz_mol"]
    all_atom_dist=kwargs["all_atom_dist"]
    bin_min=kwargs["bin_min"]
    bin_max=kwargs["bin_max"]
    bin_size=kwargs["bin_size"]
    resnum=kwargs["resnum"]
    # get_metadata=kwargs["get_metadata"]
    # rdkit_mol=kwargs["rdkit_mol"]
    toprint=kwargs["toprint"]

    formats.message("Counting hydrogen bond donor/acceptor pairs...",toprint=toprint)

    # Identify h-bond donors and acceptors in peptide and hla
    pep_hbond_donors=[]
    pep_hbond_acceptors=[]
    hla_hbond_donors=[]
    hla_hbond_acceptors=[]

    # Get donors and acceptors for the entire peptide, and add the atoms to a list of donors and acceptors
    # Use the same naming convention used by tools.utils.get_distance_matrix as an element in each list to allow for cross-referencing index values in the all-atom distance matrix
    for f in pep_feat:
        if f.GetFamily() == "Acceptor":
            atom_indx=f.GetAtomIds()
            for i in atom_indx:
                a=pep_mol.GetAtomWithIdx(i)
                pep_hbond_acceptors.append(
                    str(a.GetPDBResidueInfo().GetResidueNumber())+"_"+
                    a.GetPDBResidueInfo().GetChainId()+"_"+
                    str(a.GetIdx()))
        elif f.GetFamily() == "Donor":
            atom_indx=f.GetAtomIds()
            for i in atom_indx:
                a=pep_mol.GetAtomWithIdx(i)
                pep_hbond_donors.append(
                    str(a.GetPDBResidueInfo().GetResidueNumber())+"_"+
                    a.GetPDBResidueInfo().GetChainId()+"_"+
                    str(a.GetIdx()))

    for f in hla_feat:
        if f.GetFamily() == "Acceptor":
            atom_indx=f.GetAtomIds()
            for i in atom_indx:
                a=hla_mol.GetAtomWithIdx(i)
                hla_hbond_acceptors.append(
                    str(a.GetPDBResidueInfo().GetResidueNumber())+"_"+
                    a.GetPDBResidueInfo().GetChainId()+"_"+
                    str(a.GetIdx()))
        elif f.GetFamily() == "Donor":
            atom_indx=f.GetAtomIds()
            for i in atom_indx:
                a=hla_mol.GetAtomWithIdx(i)
                hla_hbond_donors.append(
                    str(a.GetPDBResidueInfo().GetResidueNumber())+"_"+
                    a.GetPDBResidueInfo().GetChainId()+"_"+
                    str(a.GetIdx()))

    # If user requests features summed for distance bins across the entire peptide, set a special flag that will tell us to add feature counts in distance bins across each residue and adjust the output dimensions accordingly.
    resnum_flag=False
    if resnum[0]=="all":
        resnum=[]
        [resnum.append(x.split("_")[0]) for x in all_atom_dist.columns.tolist() if x.split("_")[0] not in resnum]
        resnum_flag=True

    # For every residue in the peptide, find atoms identified as hbond donors or acceptors. Then retrieve inter-atomic distances from the all-atom distance matrix by indexing against hla donors and acceptors. Finally, iterate through the discretized distance bins and sum the donor/acceptor pairs at each distance bin.
    bin_num=int((bin_max-bin_min)/bin_size)
    pep_donor_hla_acceptors=[]
    pep_acceptor_hla_donors=[]
    for r in resnum:
        pep_res_donor_idx=[x for x in pep_hbond_donors if str(r) in x]
        pep_res_acceptor_idx=[x for x in pep_hbond_acceptors if str(r) in x]
        # Retrieve inter-atomic distance for our donor/acceptor pairings
        res_pep_donor_hla_acceptors=all_atom_dist.loc[hla_hbond_acceptors,pep_res_donor_idx]
        res_pep_acceptor_hla_donors=all_atom_dist.loc[hla_hbond_donors,pep_res_acceptor_idx]
        # Now iterate through each bin and count the number of donor/acceptor pairings at each discretized distance:
        tmp_pep_donor_hla_acceptors=[]
        tmp_pep_acceptor_hla_donors=[]
        for b in range(bin_num):
            tmp_pep_donor_hla_acceptors.append(res_pep_donor_hla_acceptors[
                (res_pep_donor_hla_acceptors<b*bin_size+bin_size) &
                (res_pep_donor_hla_acceptors>=b*bin_size)
                ].count().sum())
            tmp_pep_acceptor_hla_donors.append(res_pep_acceptor_hla_donors[
                (res_pep_acceptor_hla_donors<b*bin_size+bin_size) &
                (res_pep_acceptor_hla_donors>=b*bin_size)
                ].count().sum())
            
        # Keep a running sum of donor/acceptor pairs at each discretized distance rather than per-residue, if the user requested "pep" as the interface scope:
        if resnum_flag and pep_donor_hla_acceptors:
            pep_donor_hla_acceptors=[sum(x) for x in zip(pep_donor_hla_acceptors,tmp_pep_donor_hla_acceptors)]
            pep_acceptor_hla_donors=[sum(x) for x in zip(pep_acceptor_hla_donors,tmp_pep_acceptor_hla_donors)]
        else:
            pep_donor_hla_acceptors.extend(tmp_pep_donor_hla_acceptors)
            pep_acceptor_hla_donors.extend(tmp_pep_acceptor_hla_donors)
    
    hbond_features=pep_donor_hla_acceptors+pep_acceptor_hla_donors
    # Now generate our feature titles
    # Adjust the "resnum" vector to start from 1 and end at the number of residues
    resnum=[int(x)+1 for x in range(len(resnum))]
    if resnum_flag:
        feature_titles=[
            f"hbond_pep_donor_hla_acceptor_bin{x}" for x in range(bin_num)]+[
            f"hbond_pep_acceptor_hla_donor_bin{x}" for x in range(bin_num)
            ]
    else:
        feature_titles=[
            f"hbond_pep_donor_hla_acceptor_res{x}_bin{y}" for x in resnum for y in range(bin_num)]+[
            f"hbond_pep_acceptor_hla_donor_res{x}_bin{y}" for x in resnum for y in range(bin_num)
        ]
    # Output dataframe
    hbond_features=pd.DataFrame([hbond_features],columns=feature_titles)
    return hbond_features
    
    # Legacy code for metadata generation:
    # def get_hbond_info(donor_atom,acceptor_atom,pep_mol,hla_mol,xyz_mol):
    #     '''
    #     Usage:
    #     $ hbond_info=get_hbond_info(*args,**kwargs)

    #     Positional arguments:
    #     > donor_atom:    rdkit atom object for h-
    #                      bond donor
    #     > acceptor_atom: rdkit atom object for h-
    #                      bond acceptor
    #     > pep_mol:  rdkit mol object for the peptide
    #     > hla_mol:  rdkit mol object for the hla
    #     > xyz_mol:  pandas dataframe with atomic 
    #                 coordinates

    #     Keyword arguments:

    #     Outputs:
    #     > Tuple containing the h-bond distance
    #       (index 0) and angle in degrees (index
    #       1).
    #     '''

    #     # Retrieve our coordinate data and atoms that neighbor our donor atom
    #     neighbors=donor_atom.GetNeighbors()
    #     donor_xyz=xyz_mol[["x","y","z"]].loc[(xyz_mol["chain_id"]==donor_atom.GetPDBResidueInfo().GetChainId()) & (xyz_mol["res_name"]==donor_atom.GetPDBResidueInfo().GetResidueName()) & (xyz_mol["atom_name"]==donor_atom.GetPDBResidueInfo().GetName().strip()) & (xyz_mol["res_num"]==donor_atom.GetPDBResidueInfo().GetResidueNumber())]
    #     acceptor_xyz=xyz_mol[["x","y","z"]].loc[(xyz_mol["chain_id"]==acceptor_atom.GetPDBResidueInfo().GetChainId()) & (xyz_mol["res_name"]==acceptor_atom.GetPDBResidueInfo().GetResidueName()) & (xyz_mol["atom_name"]==acceptor_atom.GetPDBResidueInfo().GetName().strip()) & (xyz_mol["res_num"]==acceptor_atom.GetPDBResidueInfo().GetResidueNumber())]

    #     # Step 1 (less straightfoward): determine if donor atom is tertiary with freely rotatable H-bond
    #     if len(neighbors)==1 and neighbors[0].GetBonds()[0].GetBondType().name=="SINGLE":
    #         # Calculate Hbond distance and angle if donor bond is freely rotatable
    #         neighbors=neighbors[0]
    #         neighbor_xyz=xyz_mol[["x","y","z"]].loc[(xyz_mol["chain_id"]==neighbors.GetPDBResidueInfo().GetChainId()) & (xyz_mol["res_name"]==neighbors.GetPDBResidueInfo().GetResidueName()) & (xyz_mol["atom_name"]==neighbors.GetPDBResidueInfo().GetName().strip()) & (xyz_mol["res_num"]==neighbors.GetPDBResidueInfo().GetResidueNumber())]
    #         # Step one: calculate the angle, theta, between donor->hydrogen and donor->acceptor vectors
    #         v1=np.array([acceptor_xyz["x"].iloc[0]-donor_xyz["x"].iloc[0],acceptor_xyz["y"].iloc[0]-donor_xyz["y"].iloc[0],acceptor_xyz["z"].iloc[0]-donor_xyz["z"].iloc[0]])
    #         v2=np.array([donor_xyz["x"].iloc[0]-neighbor_xyz["x"].iloc[0],donor_xyz["y"].iloc[0]-neighbor_xyz["y"].iloc[0],donor_xyz["z"].iloc[0]-neighbor_xyz["z"].iloc[0]])
    #         # Step one: calculate theta, an angle necessary to determining hbond angle
    #         theta=135-np.degrees(np.arccos(np.dot(v1/np.linalg.norm(v1),v2/np.linalg.norm(v2))))
    #         # Step two: calculate distance between acceptor and donor
    #         d_da=np.linalg.norm(v1)
    #         # Step three: Use law of cosines to calculate distance from H to acceptor atom
    #         hbond_dist=np.sqrt(1+d_da**2-2*d_da*np.cos(np.radians(theta)))
    #         # Step four: calculate the angle of the h-bond using law of sins
    #         hbond_angle=np.degrees(np.arcsin(np.sin(np.radians(theta))/hbond_dist*d_da))
    #     else:
    #         # Get the attached hydrogen coordinates. The hydrogen in question will the one in the residue that is closest to the donor atom.
    #         donor_h=xyz_mol.loc[(xyz_mol["chain_id"]==donor_atom.GetPDBResidueInfo().GetChainId()) & (xyz_mol["res_name"]==donor_atom.GetPDBResidueInfo().GetResidueName()) & (xyz_mol["elem"]=="H") & (xyz_mol["res_num"]==donor_atom.GetPDBResidueInfo().GetResidueNumber())].copy(deep=True)
    #         dist_vals=[]
    #         for i in range(len(donor_h)):
    #             d_v=np.array([donor_h["x"].iloc[i]-donor_xyz["x"].iloc[0],donor_h["y"].iloc[i]-donor_xyz["y"].iloc[0],donor_h["z"].iloc[i]-donor_xyz["z"].iloc[0]])
    #             dist_vals.append(np.linalg.norm(d_v))
    #         donor_h["dist_vals"]=dist_vals
    #         h_xyz=donor_h[["x","y","z"]].loc[donor_h["dist_vals"]==donor_h["dist_vals"].min()]
    #         # Now calculate the distance from the hydrogen to the acceptor atom
    #         v1=np.array([h_xyz["x"].iloc[0]-acceptor_xyz["x"].iloc[0],h_xyz["y"].iloc[0]-acceptor_xyz["y"].iloc[0],h_xyz["z"].iloc[0]-acceptor_xyz["z"].iloc[0]])
    #         hbond_dist=np.linalg.norm(v1)
    #         # Finally, calculate donor-acceptor distance and use law of cosines to calculate H-bond angle
    #         d_da=np.linalg.norm(np.array([acceptor_xyz["x"].iloc[0]-donor_xyz["x"].iloc[0],acceptor_xyz["y"].iloc[0]-donor_xyz["y"].iloc[0],acceptor_xyz["z"].iloc[0]-donor_xyz["z"].iloc[0]]))
    #         d=donor_h["dist_vals"].min()
    #         hbond_angle=np.degrees(np.arccos((d**2+hbond_dist**2-d_da**2)/(2*d*hbond_dist)))

    #     return hbond_dist,hbond_angle

def atom_hydrophobic(**kwargs):
    '''
    Usage:
    $ atom_hydrophobic(*args,**kwargs)

    Keyword arguments:
    > pep_feat: rdkit feature object for the peptide
    > pep_mol:  rdkit mol object for the peptide
    > hla_feat: rdkit feature object for the HLA
    > hla_mol:  rdkit mol object for the hla
    > xyz_mol:  pandas dataframe with atomic 
                coordinates
    > all_atom_dist: all-atom distance matrix in
                pandas dataframe, generated by
                tools.utils.get_distance_matrix
    > bin_min:  Minimum distance to calculate
                feature in angstroms
    > bin_max:  Maximum distance to calculate
                feature in angstroms
    > bin_size: Size in angstroms of distance 
                bins
    > resnum:   Flag corresponding to 'interface
                scope' value in feature generation.
                If set to 'all', will sum features at
                discretized distances across all
                residues. Otherwise will be set to
                a list of residue numbers for which
                featurization will be performed
                independently
    > get_metadata: Flag indicating metadata should
                    be retrieved [LEGACY]
    > rdkit_mol: rdkit mol object for the peptide/hla
                complex
    > to_print: whether or not the standard progress
                messaging for this function should
                print to the screen (set to False
                when multitasking to avoid spamming
                the standard output)
    
    Note: bins are determined [bin_min,bind_max)

    Outputs:
    > Dataframe with counts of hydrophobic/hydrophobic
      hydrophobic/non-hydrophobic pairings
      
      Feature column naming convention:
      <hydrophobic_pep_hydro_hla_hydro_res{x}_bin{y}>
      and
      <hydrophobic_pep_hydro_hla_nonhydro_res{x}_bin{y}>
      and
      <hydrophobic_pep_nonhydro_hla_hydro_res{x}_bin{y}>
      and
      <hydrophobic_pep_nonhydro_hla_nonhydro_res{x}_bin{y}>

      res{x}: x is the residue number from N to 
      C terminus (1 to N, where N is the total 
      number of residues in the peptide). This
      suffix is omitted if the user opts to sum
      features over the entire peptide (interface
      scope set to "pep").

      bin{y}: y is the discretized distance bin 
      number.
      '''

    # Approach:
    # Hydrophobicity is treated as a binary property. Pairings are made with respect to the peptide atom and the hla atom. For instance, "hydrophobic_nonhydrophobic" counts the number of nonhydrophobic HLA atoms within distance [bin_low, bin_high) of the hydrophobic peptide atom
    
    # Define our standard keyword arguments used for all atom_features methods (arguments not used by this method are commented out)
    pep_feat=kwargs["pep_feat"]
    pep_mol=kwargs["pep_mol"]
    hla_feat=kwargs["hla_feat"]
    hla_mol=kwargs["hla_mol"]
    # xyz_mol=kwargs["xyz_mol"]
    all_atom_dist=kwargs["all_atom_dist"]
    bin_min=kwargs["bin_min"]
    bin_max=kwargs["bin_max"]
    bin_size=kwargs["bin_size"]
    resnum=kwargs["resnum"]
    # get_metadata=kwargs["get_metadata"]
    # rdkit_mol=kwargs["rdkit_mol"]
    toprint=kwargs["toprint"]

    formats.message("Determining hydrophobic interactions...",toprint=toprint)

    # Retrieve our hydrophobic and nonhydrophobic atoms from the peptide and HLA
    pep_hydrophobic=[]
    pep_nonhydrophobic=[]
    hla_hydrophobic=[]
    hla_nonhydrophobic=[]

    # Get hydrohpobic and non hydrophobic atoms for peptide and HLA
    for f in pep_feat:
        if f.GetFamily() in ["Hydrophobe","LumpedHydrophobe"]:
            atom_indx=f.GetAtomIds()
            for i in atom_indx:
                a=pep_mol.GetAtomWithIdx(i)
                pep_hydrophobic.append(
                    str(a.GetPDBResidueInfo().GetResidueNumber())+"_"+
                    a.GetPDBResidueInfo().GetChainId()+"_"+
                    str(a.GetIdx()))
        else:
            atom_indx=f.GetAtomIds()
            for i in atom_indx:
                a=pep_mol.GetAtomWithIdx(i)
                pep_nonhydrophobic.append(
                    str(a.GetPDBResidueInfo().GetResidueNumber())+"_"+
                    a.GetPDBResidueInfo().GetChainId()+"_"+
                    str(a.GetIdx()))

    for f in hla_feat:
        if f.GetFamily() in ["Hydrophobe","LumpedHydrophobe"]:
            atom_indx=f.GetAtomIds()
            for i in atom_indx:
                a=hla_mol.GetAtomWithIdx(i)
                hla_hydrophobic.append(
                    str(a.GetPDBResidueInfo().GetResidueNumber())+"_"+
                    a.GetPDBResidueInfo().GetChainId()+"_"+
                    str(a.GetIdx()))
        else:
            atom_indx=f.GetAtomIds()
            for i in atom_indx:
                a=hla_mol.GetAtomWithIdx(i)
                hla_nonhydrophobic.append(
                    str(a.GetPDBResidueInfo().GetResidueNumber())+"_"+
                    a.GetPDBResidueInfo().GetChainId()+"_"+
                    str(a.GetIdx()))

    # If user requests features summed for distance bins across the entire peptide, set a special flag that will tell us to add feature counts in distance bins across each residue and adjust the output dimensions accordingly.
    resnum_flag=False
    if resnum[0]=="all":
        resnum=[]
        [resnum.append(x.split("_")[0]) for x in all_atom_dist.columns.tolist() if x.split("_")[0] not in resnum]
        resnum_flag=True

    # For every residue in the peptide, find atoms identified as hydrophobic or nonhydrophobic. Then retrieve inter-atomic distances from the all-atom distance matrix by indexing against hla hydrohpobes and non-hydrophobes. Finally, iterate through the discretized distance bins and sum the donor/acceptor pairs at each distance bin.
    bin_num=int((bin_max-bin_min)/bin_size)
    pep_hydro_hla_hydro=[]
    pep_hydro_hla_nonhydro=[]
    pep_nonhydro_hla_hydro=[]
    pep_nonhydro_hla_nonhydro=[]
    for r in resnum:
        # Retrieve peptide atom indicies for atoms that are hydrophobic and nonhydrophobic in residue r:
        pep_hydro_idx=[x for x in pep_hydrophobic if str(r) in x]
        pep_nonhydro_idx=[x for x in pep_nonhydrophobic if str(r) in x]

        # Retrieve inter-atomic distances for our combinatorial pairings:
        res_pep_hydro_hla_hydro=all_atom_dist.loc[
            hla_hydrophobic,
            pep_hydro_idx
        ]
        res_pep_hydro_hla_nonhydro=all_atom_dist.loc[
            hla_nonhydrophobic,
            pep_hydro_idx
        ]
        res_pep_nonhydro_hla_hydro=all_atom_dist.loc[
            hla_hydrophobic,
            pep_nonhydro_idx
        ]
        res_pep_nonhydro_hla_nonhydro=all_atom_dist.loc[
            hla_nonhydrophobic,
            pep_nonhydro_idx
        ]
        # Now iterate through each bin and count the number of donor/acceptor pairings at each discretized distance:
        tmp_pep_hydro_hla_hydro=[]
        tmp_pep_hydro_hla_nonhydro=[]
        tmp_pep_nonhydro_hla_hydro=[]
        tmp_pep_nonhydro_hla_nonhydro=[]
        for b in range(bin_num):
            tmp_pep_hydro_hla_hydro.append(res_pep_hydro_hla_hydro[
                (res_pep_hydro_hla_hydro<b*bin_size+bin_size) &
                (res_pep_hydro_hla_hydro>=b*bin_size)
                ].count().sum()
            )
            tmp_pep_hydro_hla_nonhydro.append(res_pep_hydro_hla_nonhydro[
                (res_pep_hydro_hla_nonhydro<b*bin_size+bin_size) &
                (res_pep_hydro_hla_nonhydro>=b*bin_size)
                ].count().sum()
            )
            tmp_pep_nonhydro_hla_hydro.append(res_pep_nonhydro_hla_hydro[
                (res_pep_nonhydro_hla_hydro<b*bin_size+bin_size) &
                (res_pep_nonhydro_hla_hydro>=b*bin_size)
                ].count().sum()
            )
            tmp_pep_nonhydro_hla_nonhydro.append(res_pep_nonhydro_hla_nonhydro[
                (res_pep_nonhydro_hla_nonhydro<b*bin_size+bin_size) &
                (res_pep_nonhydro_hla_nonhydro>=b*bin_size)
                ].count().sum()
            )
        # Keep a running sum of hydrophobic pairings at each discretized distance rather than per-residue, if the user requested "pep" as the interface scope:
        if resnum_flag and pep_hydro_hla_hydro:
            pep_hydro_hla_hydro=[sum(x) for x in zip(
                pep_hydro_hla_hydro,
                tmp_pep_hydro_hla_hydro
            )]
            pep_hydro_hla_nonhydro=[sum(x) for x in zip(
                pep_hydro_hla_nonhydro,
                tmp_pep_hydro_hla_nonhydro
            )]
            pep_nonhydro_hla_hydro=[sum(x) for x in zip(
                pep_nonhydro_hla_hydro,
                tmp_pep_nonhydro_hla_hydro
            )]
            pep_nonhydro_hla_nonhydro=[sum(x) for x in zip(
                pep_nonhydro_hla_nonhydro,
                tmp_pep_nonhydro_hla_nonhydro
            )]
        else:
            pep_hydro_hla_hydro.extend(tmp_pep_hydro_hla_hydro)
            pep_hydro_hla_nonhydro.extend(tmp_pep_hydro_hla_nonhydro)
            pep_nonhydro_hla_hydro.extend(tmp_pep_nonhydro_hla_hydro)
            pep_nonhydro_hla_nonhydro.extend(tmp_pep_nonhydro_hla_nonhydro)

    hydrophobic_features=pep_hydro_hla_hydro+pep_hydro_hla_nonhydro+pep_nonhydro_hla_hydro+pep_nonhydro_hla_nonhydro
    # Now generate our feature titles
    # Adjust the "resnum" vector to start from 1 and end at the number of residues
    resnum=[int(x)+1 for x in range(len(resnum))]
    if resnum_flag:
        feature_titles=[
            f"hydrophobic_pep_hydro_hla_hydro_bin{x}" for x in range(bin_num)]+[
            f"hydrophobic_pep_hydro_hla_nonhydro_bin{x}" for x in range(bin_num)]+[
            f"hydrophobic_pep_nonhydro_hla_hydro_bin{x}" for x in range(bin_num)]+[
            f"hydrophobic_pep_nonhydro_hla_nonhydro_bin{x}" for x in range(bin_num)]+[
            ]
    else:
        feature_titles=[
            f"hydrophobic_pep_hydro_hla_hydro_res{x}_bin{y}" for x in resnum for y in range(bin_num)]+[
            f"hydrophobic_pep_hydro_hla_nonhydro_res{x}_bin{y}" for x in resnum for y in range(bin_num)]+[
            f"hydrophobic_pep_nonhydro_hla_hydro_res{x}_bin{y}" for x in resnum for y in range(bin_num)]+[
            f"hydrophobic_pep_nonhydro_hla_nonhydro_res{x}_bin{y}" for x in resnum for y in range(bin_num)]+[
        ]
    # Output dataframe
    hydrophobic_features=pd.DataFrame([hydrophobic_features],columns=feature_titles)
    return hydrophobic_features

def atom_electrostatic(**kwargs):
    '''
    Usage:
    $ atom_electrostatic(*args,**kwargs)

    Keyword arguments:
    > pep_feat: rdkit feature object for the peptide
    > pep_mol:  rdkit mol object for the peptide
    > hla_feat: rdkit feature object for the HLA
    > hla_mol:  rdkit mol object for the hla
    > xyz_mol:  pandas dataframe with atomic 
                coordinates
    > all_atom_dist: all-atom distance matrix in
                pandas dataframe, generated by
                tools.utils.get_distance_matrix
    > bin_min:  Minimum distance to calculate
                feature in angstroms
    > bin_max:  Maximum distance to calculate
                feature in angstroms
    > bin_size: Size in angstroms of distance 
                bins
    > resnum:   Flag corresponding to 'interface
                scope' value in feature generation.
                If set to 'all', will sum features at
                discretized distances across all
                residues. Otherwise will be set to
                a list of residue numbers for which
                featurization will be performed
                independently
    > get_metadata: Flag indicating metadata should
                    be retrieved [LEGACY]
    > rdkit_mol: rdkit mol object for the peptide/hla
                complex
    > to_print: whether or not the standard progress
                messaging for this function should
                print to the screen (set to False
                when multitasking to avoid spamming
                the standard output)

    Note: bins are determined [bin_min,bind_max)

    Outputs:
    > Dataframe containing counts of electrostatic pairings
      and net coulombic attractive and repulsive forces on
      peptide atoms at the interface.

      Feature column naming convention:
      <electrostatic_pep_pos_hla_pos_res{x}_bin{y}>
      and
      <electrostatic_pep_pos_hla_neg_res{x}_bin{y}>
      and
      <electrostatic_pep_neg_hla_pos_res{x}_bin{y}>
      and
      <electrostatic_pep_neg_hla_neg_res{x}_bin{y}>
      and
      <electrostatic_coulombic_net_res{x}_bin{y}>

      res{x}: x is the residue number from N to 
      C terminus (1 to N, where N is the total 
      number of residues in the peptide). This
      suffix is omitted if the user opts to sum
      features over the entire peptide (interface
      scope set to "pep").

      bin{y}: y is the discretized distance bin 
      number.
    '''

    def get_coulomb_force(pep_atom,hla_atom,xyz_mol):
        '''
        Usage:
        $ get_coulomb_force(*args,**kwargs)

        Positional arguments:
        > pep_atom: rdkit feature object for the 
                    peptide atom
        > hla_atom: rdkit atom object for the hla
                    atom 
        > xyz_mol:  pandas dataframe with atomic 
                    coordinates

        Keyword arguments:

        Outputs:
        > Coulomb force between atoms with 
        "_GeistegerCharge" property, calculated with
        (pep_atom charge)*(hla_atom charge)/distance^2
        Dielectric constant is assumed to be 1 (ultimately, since
        these net values will be standardized and used as inputs
        for a NN, the selection of dielectric constant does not
        matter)
        '''
        # Get the x,y, and z coordinates for our peptide and hla atoms:
        pep_xyz=xyz_mol[["x","y","z"]].loc[(xyz_mol["chain_id"]==pep_atom.GetPDBResidueInfo().GetChainId()) & (xyz_mol["res_name"]==pep_atom.GetPDBResidueInfo().GetResidueName()) & (xyz_mol["atom_name"]==pep_atom.GetPDBResidueInfo().GetName().strip()) & (xyz_mol["res_num"]==pep_atom.GetPDBResidueInfo().GetResidueNumber())]
        hla_xyz=xyz_mol[["x","y","z"]].loc[(xyz_mol["chain_id"]==hla_atom.GetPDBResidueInfo().GetChainId()) & (xyz_mol["res_name"]==hla_atom.GetPDBResidueInfo().GetResidueName()) & (xyz_mol["atom_name"]==hla_atom.GetPDBResidueInfo().GetName().strip()) & (xyz_mol["res_num"]==hla_atom.GetPDBResidueInfo().GetResidueNumber())]

        # Calculate the distance between them:
        d=np.linalg.norm(np.array([pep_xyz["x"].iloc[0]-hla_xyz["x"].iloc[0],pep_xyz["y"].iloc[0]-hla_xyz["y"].iloc[0],pep_xyz["z"].iloc[0]-hla_xyz["z"].iloc[0]]))

        # Retrieve their computed partial charges:
        pep_q=float(pep_atom.GetProp("_GasteigerCharge"))
        hla_q=float(hla_atom.GetProp("_GasteigerCharge"))

        # Calculate the coulomb force between them (negative is attractive, positive is repulsive)
        coulomb_force=((pep_q)*(hla_q))/(d**2)

        return coulomb_force

    # Approach:
    # We will consider both the binary property of opposite/same charge neighbors, and the net magnitude of the columbic forces on a peptide atom at a given distance bin (neg=attractive, pos=repulsive) 

    # Define our standard keyword arguments used for all atom_features methods (arguments not used by this method are commented out)
    pep_feat=kwargs["pep_feat"]
    pep_mol=kwargs["pep_mol"]
    hla_feat=kwargs["hla_feat"]
    hla_mol=kwargs["hla_mol"]
    xyz_mol=kwargs["xyz_mol"]
    all_atom_dist=kwargs["all_atom_dist"]
    bin_min=kwargs["bin_min"]
    bin_max=kwargs["bin_max"]
    bin_size=kwargs["bin_size"]
    resnum=kwargs["resnum"]
    # get_metadata=kwargs["get_metadata"]
    # rdkit_mol=kwargs["rdkit_mol"]
    toprint=kwargs["toprint"]

    formats.message("Quantifying electrostatic interactions...",toprint=toprint)


    # Retrieve our postive and negatively atoms from the peptide and HLA
    pep_pos=[]
    pep_neg=[]
    hla_pos=[]
    hla_neg=[]

    # Get negative and positively charged non-hydrophobes
    # First, collect all atom Ids that are classified as hydrophobes or lumped hydrophobes
    pep_exclude_hydrophobe_ids=[]
    for f in pep_feat:
        if f.GetFamily() in ["Hydrophobe","LumpedHydrophobe"]:
            pep_exclude_hydrophobe_ids.extend(list(f.GetAtomIds()))
    hla_exclude_hydrophobe_ids=[]
    for f in hla_feat:
        if f.GetFamily() in ["Hydrophobe","LumpedHydrophobe"]:
            hla_exclude_hydrophobe_ids.extend(list(f.GetAtomIds()))

    # Next, iterate through each atom in the peptide and HLA molecules, adding to our list of negatively or positively partially charged atoms ONLY IF they are not in our list of hydrophobes or lumped hydrophobes.
    for a in pep_mol.GetAtoms():
        atom_indx=a.GetIdx()
        if atom_indx not in pep_exclude_hydrophobe_ids:
            gc=float(a.GetProp("_GasteigerCharge"))
            if gc>0:
                pep_pos.append(
                    str(a.GetPDBResidueInfo().GetResidueNumber())+"_"+
                    a.GetPDBResidueInfo().GetChainId()+"_"+
                    str(a.GetIdx()))
            elif gc<0:
                pep_neg.append(
                    str(a.GetPDBResidueInfo().GetResidueNumber())+"_"+
                    a.GetPDBResidueInfo().GetChainId()+"_"+
                    str(a.GetIdx()))
                
    for a in hla_mol.GetAtoms():
        atom_indx=a.GetIdx()
        if atom_indx not in hla_exclude_hydrophobe_ids:
            gc=float(a.GetProp("_GasteigerCharge"))
            if gc>0:
                hla_pos.append(
                    str(a.GetPDBResidueInfo().GetResidueNumber())+"_"+
                    a.GetPDBResidueInfo().GetChainId()+"_"+
                    str(a.GetIdx()))
            elif gc<0:
                hla_neg.append(
                    str(a.GetPDBResidueInfo().GetResidueNumber())+"_"+
                    a.GetPDBResidueInfo().GetChainId()+"_"+
                    str(a.GetIdx()))
    # If user requests features summed for distance bins across the entire peptide, set a special flag that will tell us to add feature counts in distance bins across each residue and adjust the output dimensions accordingly.
    resnum_flag=False
    if resnum[0]=="all":
        resnum=[]
        [resnum.append(x.split("_")[0]) for x in all_atom_dist.columns.tolist() if x.split("_")[0] not in resnum]
        resnum_flag=True

    # Sum electorstatic charge pairings totals for each discretized distance bin
    bin_num=int((bin_max-bin_min)/bin_size)
    # Initialize lists for pairing counts at each bin
    pep_pos_hla_pos=[]
    pep_neg_hla_pos=[]
    pep_pos_hla_neg=[]
    pep_neg_hla_neg=[]
    coulomb_net=[]
    for r in resnum:
        # Retrieve the peptide atom indicies for atoms with positive and negative charge in residue r:
        pep_pos_idx=[x for x in pep_pos if str(r) in x]
        pep_neg_idx=[x for x in pep_neg if str(r) in x]

        # Retrieve inter-atomic distances for our combinatorial pairings:
        res_pep_pos_hla_pos=all_atom_dist.loc[
            hla_pos,
            pep_pos_idx
        ]
        res_pep_pos_hla_neg=all_atom_dist.loc[
            hla_neg,
            pep_pos_idx
        ]
        res_pep_neg_hla_pos=all_atom_dist.loc[
            hla_pos,
            pep_neg_idx
        ]
        res_pep_neg_hla_neg=all_atom_dist.loc[
            hla_neg,
            pep_neg_idx
        ]
        # This dataframe will contain indices and inter-atomic distance values corresponding to charged hla atoms and charged peptide atoms in a given residue
        res_coulomb=all_atom_dist.loc[
            hla_pos+hla_neg,
            pep_pos_idx+pep_neg_idx
        ]
        # Now iterate through each bin and count the number of donor/acceptor pairings at each discretized distance:
        tmp_pep_pos_hla_pos=[]
        tmp_pep_neg_hla_pos=[]
        tmp_pep_pos_hla_neg=[]
        tmp_pep_neg_hla_neg=[]
        tmp_coulomb_total_per_bin=[]
        for b in range(bin_num):
            tmp_pep_pos_hla_pos.append(res_pep_pos_hla_pos[
                (res_pep_pos_hla_pos<b*bin_size+bin_size) &
                (res_pep_pos_hla_pos>=b*bin_size)
                ].count().sum()
            )
            tmp_pep_neg_hla_pos.append(res_pep_neg_hla_pos[
                (res_pep_neg_hla_pos<b*bin_size+bin_size) &
                (res_pep_neg_hla_pos>=b*bin_size)
                ].count().sum()
            )
            tmp_pep_pos_hla_neg.append(res_pep_pos_hla_neg[
                (res_pep_pos_hla_neg<b*bin_size+bin_size) &
                (res_pep_pos_hla_neg>=b*bin_size)
                ].count().sum()
            )
            tmp_pep_neg_hla_neg.append(res_pep_neg_hla_neg[
                (res_pep_neg_hla_neg<b*bin_size+bin_size) &
                (res_pep_neg_hla_neg>=b*bin_size)
                ].count().sum()
            )

            # For calculation of total coulomb force, first retrieve the indices of HLA and peptide atoms of interest.
            coulomb_pairs=res_coulomb[
                (res_coulomb<b*bin_size+bin_size) &
                (res_coulomb>=b*bin_size)
            ]
            # Next, for each charged atom in the peptide residue, calculate the net coulomb force experienced by that atom 
            bin_net_coulomb=0
            for pep_atom_idx in coulomb_pairs.columns:
                hla_atoms=coulomb_pairs[pep_atom_idx].loc[coulomb_pairs[pep_atom_idx].notnull()]
                if not hla_atoms.empty:
                    pep_atom_idx=int(pep_atom_idx.split("_")[-1])
                    hla_atom_idx=[int(x.split("_")[-1]) for x in hla_atoms.index.tolist()]
                    pep_atom=pep_mol.GetAtomWithIdx(pep_atom_idx)
                    for idx in hla_atom_idx:
                        hla_atom=hla_mol.GetAtomWithIdx(idx)
                        bin_net_coulomb+=get_coulomb_force(pep_atom,hla_atom,xyz_mol)
            tmp_coulomb_total_per_bin.append(bin_net_coulomb)

        # Keep a running sum of electrostatic pairings at each discretized distance rather than per-residue, if the user requested "pep" as the interface scope:
        if resnum_flag and pep_pos_hla_pos:
            pep_pos_hla_pos=[sum(x) for x in zip(
                pep_pos_hla_pos,
                tmp_pep_pos_hla_pos
            )]
            pep_neg_hla_pos=[sum(x) for x in zip(
                pep_neg_hla_pos,
                tmp_pep_neg_hla_pos
            )]
            pep_pos_hla_neg=[sum(x) for x in zip(
                pep_pos_hla_neg,
                tmp_pep_pos_hla_neg
            )]
            pep_neg_hla_neg=[sum(x) for x in zip(
                pep_neg_hla_neg,
                tmp_pep_neg_hla_neg
            )]
            coulomb_net=[sum(x) for x in zip(
                coulomb_net,
                tmp_coulomb_total_per_bin
            )]
        else:
            pep_pos_hla_pos.extend(tmp_pep_pos_hla_pos)
            pep_neg_hla_pos.extend(tmp_pep_neg_hla_pos)
            pep_pos_hla_neg.extend(tmp_pep_pos_hla_neg)
            pep_neg_hla_neg.extend(tmp_pep_neg_hla_neg)
            coulomb_net.extend(tmp_coulomb_total_per_bin)
            
    electrostatic_features=pep_pos_hla_pos+pep_pos_hla_neg+pep_neg_hla_pos+pep_neg_hla_neg+coulomb_net
    # Now generate our feature titles
    # Adjust the "resnum" vector to start from 1 and end at the number of residues
    resnum=[int(x)+1 for x in range(len(resnum))]
    if resnum_flag:
        feature_titles=[
            f"electrostatic_pep_pos_hla_pos_bin{x}" for x in range(bin_num)]+[
            f"electrostatic_pep_pos_hla_neg_bin{x}" for x in range(bin_num)]+[
            f"electrostatic_pep_neg_hla_pos_bin{x}" for x in range(bin_num)]+[
            f"electrostatic_pep_neg_hla_neg_bin{x}" for x in range(bin_num)]+[
            f"electrostatic_coulomb_net_bin{x}" for x in range(bin_num)]+[
            ]
    else:
        feature_titles=[
            f"electrostatic_pep_pos_hla_pos_res{x}_bin{y}" for x in resnum for y in range(bin_num)]+[
            f"electrostatic_pep_pos_hla_neg_res{x}_bin{y}" for x in resnum for y in range(bin_num)]+[
            f"electrostatic_pep_neg_hla_pos_res{x}_bin{y}" for x in resnum for y in range(bin_num)]+[
            f"electrostatic_pep_neg_hla_neg_res{x}_bin{y}" for x in resnum for y in range(bin_num)]+[
            f"electrostatic_coulomb_net_res{x}_bin{y}" for x in resnum for y in range(bin_num)
            ]
    # Output dataframe
    electrostatic_features=pd.DataFrame([electrostatic_features],columns=feature_titles)
    return electrostatic_features

def atom_VdW(**kwargs):
    '''
    Usage:
    $ atom_VdW(*args,**kwargs)

    Positional arguments:
    > pep_feat: rdkit feature object for the peptide
    > pep_mol:  rdkit mol object for the peptide
    > hla_feat: rdkit feature object for the HLA
    > hla_mol:  rdkit mol object for the hla
    > xyz_mol:  pandas dataframe with atomic 
                coordinates
    > all_atom_dist: all-atom distance matrix in
                pandas dataframe, generated by
                tools.utils.get_distance_matrix

    Keyword arguments:
    > bin_min:  Minimum distance to calculate
                feature in angstroms
    > bin_max:  Maximum distance to calculate
                feature in angstroms
    > bin_size: Size in angstroms of distance 
                bins
    > resnum:   Flag corresponding to 'interface
                scope' value in feature generation.
                If set to 'all', will sum features at
                discretized distances across all
                residues. Otherwise will be set to
                a list of residue numbers for which
                featurization will be performed
                independently
    > get_metadata: Flag indicating metadata should
                    be retrieved [LEGACY]
    > to_print: whether or not the standard progress
                messaging for this function should
                print to the screen (set to False
                when multitasking to avoid spamming
                the standard output)
        
    Note: bins are determined [bin_min,bind_max)

    Outputs:
    > Dataframe containing sum of LJ potential energies
      by discretized distance bin for peptide atoms 
      at the interface.

      Feature column naming convention:
      <LJenergyAtt_res{x}_bin{y}>
      <LJenergyRep_res{x}_bin{y}>

      Att: sum of LJ attractive forces at bin y
      Rep: sum of LJ repulsive forces at bin y

      res{x}: x is the residue number from N to 
      C terminus (1 to N, where N is the total 
      number of residues in the peptide). This
      suffix is omitted if the user opts to sum
      features over the entire peptide (interface
      scope set to "pep").

      bin{y}: y is the discretized distance bin 
      number.
    '''
    def get_LJ_energy(pep_atom,hla_atom,xyz_mol,epsilon,sigma):
        '''
        Usage:
        $ atom_VdW(*args,**kwargs)

        Positional arguments:
        > pep_atom:  peptide rdkit atom object
        > hla_atom:  hla rdkit atom object
        > xyz_mol:   Atom coordinate information
        > epsilon:   VdW well depth
        > sigma:     VdW radius

        Keyword arguments:

        Outputs:
        > Calculated Lennard-Jones potential energy
        '''
        # Retrieve atomic coordiates for each atom in the peptide...
        pep_xyz=xyz_mol[["x","y","z"]].loc[(xyz_mol["chain_id"]==pep_atom.GetPDBResidueInfo().GetChainId()) & (xyz_mol["res_name"]==pep_atom.GetPDBResidueInfo().GetResidueName()) & (xyz_mol["atom_name"]==pep_atom.GetPDBResidueInfo().GetName().strip()) & (xyz_mol["res_num"]==pep_atom.GetPDBResidueInfo().GetResidueNumber())]
        # ...and the HLA
        hla_xyz=xyz_mol[["x","y","z"]].loc[(xyz_mol["chain_id"]==hla_atom.GetPDBResidueInfo().GetChainId()) & (xyz_mol["res_name"]==hla_atom.GetPDBResidueInfo().GetResidueName()) & (xyz_mol["atom_name"]==hla_atom.GetPDBResidueInfo().GetName().strip()) & (xyz_mol["res_num"]==hla_atom.GetPDBResidueInfo().GetResidueNumber())]

        # Calculate the distance between those points in 3D space
        r=np.linalg.norm(np.array([pep_xyz["x"].iloc[0]-hla_xyz["x"].iloc[0],pep_xyz["y"].iloc[0]-hla_xyz["y"].iloc[0],pep_xyz["z"].iloc[0]-hla_xyz["z"].iloc[0]]))
        # Calculate the LJ energy
        V=4*epsilon*((sigma/r)**12-(sigma/r)**6)
        
        return V
    
    # Approach:
    # A simple calculation of net LJ potential energy for each peptide atom at each distance bin 

    # Define our standard keyword arguments used for all atom_features methods (arguments not used by this method are commented out)
    # pep_feat=kwargs["pep_feat"]
    pep_mol=kwargs["pep_mol"]
    # hla_feat=kwargs["hla_feat"]
    hla_mol=kwargs["hla_mol"]
    xyz_mol=kwargs["xyz_mol"]
    all_atom_dist=kwargs["all_atom_dist"]
    bin_min=kwargs["bin_min"]
    bin_max=kwargs["bin_max"]
    bin_size=kwargs["bin_size"]
    resnum=kwargs["resnum"]
    # get_metadata=kwargs["get_metadata"]
    rdkit_mol=kwargs["rdkit_mol"]
    toprint=kwargs["toprint"]

    formats.message("Calculating attractive and repulsive LJ energies...",toprint=toprint)

    # This part is a little tricky. For the peptide and the HLA, we have to retrieve the indicies of the atoms in the *combined* hla-peptide rdkit molecule in order to get the epsilon and sigma values to calculate LJ potentials. BUT, to reference our distance matrix indicies, we need the indices as they appear in our renumbered split peptide and hla molecules. So we get both, and assume they will correlate with each other so we can index a zipped set of lists.
    pep_atoms_split=[] # Indices of peptide atoms corresponding to column names in distance matrix
    hla_atoms_split=[] # Indices of hla atoms corresponding to row names in distance matrix
    pep_atoms_pephla=[] # atom indices (integers) of peptide atoms in rdkit molecule before splitting
    hla_atoms_pephla=[] # atom indices (integers) of hla atoms in rdkit molecule before splitting
    numatoms=rdkit_mol.GetNumAtoms()
    pep_chainID=pep_mol.GetAtomWithIdx(0).GetPDBResidueInfo().GetChainId()
    hla_chainID=hla_mol.GetAtomWithIdx(0).GetPDBResidueInfo().GetChainId()
    for i in range(numatoms):
        a=rdkit_mol.GetAtomWithIdx(i)
        if a.GetPDBResidueInfo().GetChainId()==pep_chainID:
            pep_atoms_pephla.append(i)
        elif a.GetPDBResidueInfo().GetChainId()==hla_chainID:
            hla_atoms_pephla.append(i)

    for a in pep_mol.GetAtoms():    
        pep_atoms_split.append(
            str(a.GetPDBResidueInfo().GetResidueNumber())+"_"+
                a.GetPDBResidueInfo().GetChainId()+"_"+
                str(a.GetIdx())
        )
    for a in hla_mol.GetAtoms():
        hla_atoms_split.append(
           str(a.GetPDBResidueInfo().GetResidueNumber())+"_"+
                a.GetPDBResidueInfo().GetChainId()+"_"+
                str(a.GetIdx()) 
        )
    
    # Now zip our lists together for convenience:
    pep_atoms=zip(pep_atoms_pephla,pep_atoms_split)
    hla_atoms=zip(hla_atoms_pephla,hla_atoms_split)
    
    # If user requests features summed for distance bins across the entire peptide, set a special flag that will tell us to add feature counts in distance bins across each residue and adjust the output dimensions accordingly.
    resnum_flag=False
    if resnum[0]=="all":
        resnum=[]
        [resnum.append(x.split("_")[0]) for x in all_atom_dist.columns.tolist() if x.split("_")[0] not in resnum]
        resnum_flag=True

    # For every residue in the peptide, iterate through the bin distances and find hla atom pairings, summing the total L-J potential energies.
    bin_num=int((bin_max-bin_min)/bin_size)

    # Initialize lists for pairing counts at each bin
    LJenergyAtt=[]
    LJenergyRep=[]
    for r in resnum:
        # Retrieve the peptide atom indices for the peptides in this residue:
        pep_idx=[x for x in pep_atoms_split if str(r) in x]

        # Retrieve inter-atomic distances for all combinatorial pairings for atoms in this residue:
        pep_hla_dist=all_atom_dist.loc[
            hla_atoms_split,
            pep_idx
        ]

        # Now iterate through each bin and sum the total positive and negative LJ energies at each discretized distance
        LJenergyAtt_tmp=[]
        LJenergyRep_tmp=[]
        for b in range(bin_num):
            # For every atom in our peptide residue, retrieve the HLA atoms that are within the specified distance bin. For each peptide/HLA pairing, calculate LJ energies and add them to the growing feature vector
            atoms_in_bin=pep_hla_dist[
                (pep_hla_dist<b*bin_size+bin_size) &
                (pep_hla_dist>=b*bin_size)
                ].fillna(value=False).astype("bool")
            
            # Iterate through peptide atoms...
            LJatt=0
            LJrep=0
            for c in pep_hla_dist.columns.tolist():
                # retrieve distance dataframe indices of hla_atoms within the specified distance bin of atom c
                hla_atoms=pep_hla_dist[c].loc[atoms_in_bin[c]].index.tolist()
                # If any atoms in the HLA are located...
                if hla_atoms:
                    # Get the peptide atom and hla atom rdkit objects from the peptide/hla complex molecule for LJ energy calculations (will need to calculate LJ energy for each HLA atom and add to growing values of attractive or respulsive energies)
                    pep_atom_idx=pep_atoms_split.index(c)
                    pep_atom=rdkit_mol.GetAtomWithIdx(pep_atoms_pephla[pep_atom_idx])
                    hla_atom_idx=[hla_atoms_split.index(i) for i in hla_atoms]
                    for hla_idx in hla_atom_idx:
                        hla_atom=rdkit_mol.GetAtomWithIdx(hla_atoms_pephla[hla_idx])
                        sigma_epsilon=rdForceFieldHelpers.GetUFFVdWParams(rdkit_mol,pep_atom.GetIdx(),hla_atom.GetIdx())
                        sigma=sigma_epsilon[0]
                        epsilon=sigma_epsilon[1]
                        LJ_energy=get_LJ_energy(pep_atom,hla_atom,xyz_mol,epsilon,sigma)
                        if LJ_energy<0:
                            LJatt+=LJ_energy
                        else:
                            LJrep+=LJ_energy
            LJenergyAtt_tmp.append(LJatt)
            LJenergyRep_tmp.append(LJrep)

        # Keep a running total of LJ energies at each discretized distance rather than per-residue if user specifies "pep" as the interface scope:
        if resnum_flag and LJenergyAtt:
            LJenergyAtt=[sum(x) for x in zip(
                LJenergyAtt,
                LJenergyAtt_tmp
            )]
            LJenergyRep=[sum(x) for x in zip(
                LJenergyRep,
                LJenergyRep_tmp
            )]
        else:
            LJenergyAtt.extend(LJenergyAtt_tmp)
            LJenergyRep.extend(LJenergyRep_tmp)

    VdW_energy=LJenergyAtt+LJenergyRep
    # Now generate our feature titles
    # Adjust the "resnum" vector to start from 1 and end at the number of residues
    resnum=[int(x)+1 for x in range(len(resnum))]
    if resnum_flag:
        feature_titles=[
            f"LJenergyAtt_bin{x}" for x in range(bin_num)]+[
            f"LJenergyRep_bin{x}" for x in range(bin_num)
            ]
    else:
        feature_titles=[
            f"LJenergyAtt_res{x}_bin{y}" for x in resnum for y in range(bin_num)]+[
            f"LJenergyRep_res{x}_bin{y}" for x in resnum for y in range(bin_num)
            ]
    # Output dataframe
    VdW_features=pd.DataFrame([VdW_energy],columns=feature_titles)
    return VdW_features

def atom_pipi(**kwargs):
    '''
    Usage:
    $ atom_pipi(**kwargs)

    Keyword arguments:
    > pep_feat: rdkit feature object for the peptide
    > pep_mol:  rdkit mol object for the peptide
    > hla_feat: rdkit feature object for the HLA
    > hla_mol:  rdkit mol object for the hla
    > xyz_mol:  pandas dataframe with atomic 
                coordinates
    > all_atom_dist: all-atom distance matrix in
                pandas dataframe, generated by
                tools.utils.get_distance_matrix
    > bin_min:  Minimum distance to calculate
                feature in angstroms
    > bin_max:  Maximum distance to calculate
                feature in angstroms
    > bin_size: Size in angstroms of distance 
                bins
    > resnum:   Flag corresponding to 'interface
                scope' value in feature generation.
                If set to 'all', will sum features at
                discretized distances across all
                residues. Otherwise will be set to
                a list of residue numbers for which
                featurization will be performed
                independently
    > get_metadata: Flag indicating metadata should
                    be retrieved [LEGACY]
    > rdkit_mol: rdkit mol object for the peptide/hla
                complex
    > to_print: whether or not the standard progress
                messaging for this function should
                print to the screen (set to False
                when multitasking to avoid spamming
                the standard output)
    
    Note: bins are determined [bin_min,bind_max)

    Outputs:
    > Dataframe with pi-pi bond counts at each discretized
    distance and/or residue.
      
      Feature column naming convention:
      <pipi_res{x}_bin{y}>

      res{x}: x is the residue number from N to 
      C terminus (1 to N, where N is the total 
      number of residues in the peptide). This
      suffix is omitted if the user opts to sum
      features over the entire peptide (interface
      scope set to "pep").

      bin{y}: y is the discretized distance bin 
      number.
    '''
    # Going to keep this simple to avoid extending beyond rdKit's capabilities or introducing uncessary complexities into our approach. Identify all atoms belonging to aromatic rings in peptide and HLA. Build distance matrix. Iterate through bins, counting # of atomic pairings within specified bin distnace between peptide and HLA. That's it.

    # Define our standard keyword arguments used for all atom_features methods (arguments not used by this method are commented out)
    # pep_feat=kwargs["pep_feat"]
    pep_mol=kwargs["pep_mol"]
    # hla_feat=kwargs["hla_feat"]
    hla_mol=kwargs["hla_mol"]
    # xyz_mol=kwargs["xyz_mol"]
    all_atom_dist=kwargs["all_atom_dist"]
    bin_min=kwargs["bin_min"]
    bin_max=kwargs["bin_max"]
    bin_size=kwargs["bin_size"]
    resnum=kwargs["resnum"]
    # get_metadata=kwargs["get_metadata"]
    # rdkit_mol=kwargs["rdkit_mol"]
    toprint=kwargs["toprint"]

    formats.message("Quantifying pi-pi interactions...",toprint=toprint)
    # Identify atoms with pi-pi bonds in peptide and HLA (those with "aromatic" label)
    pep_aro=[]
    hla_aro=[]
    numatoms_pep=pep_mol.GetNumAtoms()
    for i in range(numatoms_pep):
        a=pep_mol.GetAtomWithIdx(i)
        if a.GetIsAromatic():
            pep_aro.append(
                str(a.GetPDBResidueInfo().GetResidueNumber())+"_"+
                    a.GetPDBResidueInfo().GetChainId()+"_"+
                    str(a.GetIdx())
            )
    numatoms_hla=hla_mol.GetNumAtoms()
    for i in range(numatoms_hla):
        a=hla_mol.GetAtomWithIdx(i)
        if a.GetIsAromatic():
            hla_aro.append(
                str(a.GetPDBResidueInfo().GetResidueNumber())+"_"+
                    a.GetPDBResidueInfo().GetChainId()+"_"+
                    str(a.GetIdx())
            )

    # If user requests features summed for distance bins across the entire peptide, set a special flag that will tell us to add feature counts in distance bins across each residue and adjust the output dimensions accordingly.
    resnum_flag=False
    if resnum[0]=="all":
        resnum=[]
        [resnum.append(x.split("_")[0]) for x in all_atom_dist.columns.tolist() if x.split("_")[0] not in resnum]
        resnum_flag=True

    # For every residue in the peptide, find atoms identified as aromatic. Then count the number of aromatic atoms in hla atoms within the discretized distance bin
    bin_num=int((bin_max-bin_min)/bin_size)
    pipi=[]
    for r in resnum:
        pep_aro_idx=[x for x in pep_aro if str(r) in x]
        # Retrieve inter-atomic distance for our donor/acceptor pairings
        pipi_pairs=all_atom_dist.loc[
            hla_aro,
            pep_aro_idx
            ]
        # Now iterate through each bin and count the number of pi-pi pairings at each distance bin
        pipi_tmp=[]
        for b in range(bin_num):
            pipi_tmp.append(pipi_pairs[
                (pipi_pairs<b*bin_size+bin_size) &
                (pipi_pairs>=b*bin_size)
                ].count().sum())
        # Keep a running sum of pi-pi pairs at each discretized distance rather than per-residue, if the user requested "pep" as the interface scope:
        if resnum_flag and pipi:
            pipi=[sum(x) for x in zip(pipi,pipi_tmp)]
        else:
            pipi.extend(pipi_tmp)

    # Now generate our feature titles
    # Adjust the "resnum" vector to start from 1 and end at the number of residues
    resnum=[int(x)+1 for x in range(len(resnum))]
    if resnum_flag:
        feature_titles=[f"pipi_bin{x}" for x in range(bin_num)]
    else:
        feature_titles=[f"pipi_res{x}_bin{y}" for x in resnum for y in range(bin_num)]
        
    # Output dataframe
    pipi_features=pd.DataFrame([pipi],columns=feature_titles)
    return pipi_features

def atom_catpi(**kwargs):
    '''
    Usage:
    $ atom_catpi(**kwargs)

    Keyword arguments:
    > pep_feat: rdkit feature object for the peptide
    > pep_mol:  rdkit mol object for the peptide
    > hla_feat: rdkit feature object for the HLA
    > hla_mol:  rdkit mol object for the hla
    > xyz_mol:  pandas dataframe with atomic 
                coordinates
    > all_atom_dist: all-atom distance matrix in
                pandas dataframe, generated by
                tools.utils.get_distance_matrix
    > bin_min:  Minimum distance to calculate
                feature in angstroms
    > bin_max:  Maximum distance to calculate
                feature in angstroms
    > bin_size: Size in angstroms of distance 
                bins
    > resnum:   Flag corresponding to 'interface
                scope' value in feature generation.
                If set to 'all', will sum features at
                discretized distances across all
                residues. Otherwise will be set to
                a list of residue numbers for which
                featurization will be performed
                independently
    > get_metadata: Flag indicating metadata should
                    be retrieved [LEGACY]
    > rdkit_mol: rdkit mol object for the peptide/hla
                complex
    > to_print: whether or not the standard progress
                messaging for this function should
                print to the screen (set to False
                when multitasking to avoid spamming
                the standard output)
    
    Note: bins are determined [bin_min,bind_max)

    Outputs:
    > Dataframe with cat-pi interaction counts at 
    each discretized distance and/or residue.
      
      Feature column naming convention:
      <catpi_res{x}_bin{y}>
      AND
      <picat_res{x}_bin{y}>

      res{x}: x is the residue number from N to 
      C terminus (1 to N, where N is the total 
      number of residues in the peptide). This
      suffix is omitted if the user opts to sum
      features over the entire peptide (interface
      scope set to "pep").

      bin{y}: y is the discretized distance bin 
      number.
    '''
    # Define our standard keyword arguments used for all atom_features methods (arguments not used by this method are commented out)
    pep_feat=kwargs["pep_feat"]
    pep_mol=kwargs["pep_mol"]
    hla_feat=kwargs["hla_feat"]
    hla_mol=kwargs["hla_mol"]
    # xyz_mol=kwargs["xyz_mol"]
    all_atom_dist=kwargs["all_atom_dist"]
    bin_min=kwargs["bin_min"]
    bin_max=kwargs["bin_max"]
    bin_size=kwargs["bin_size"]
    resnum=kwargs["resnum"]
    # get_metadata=kwargs["get_metadata"]
    # rdkit_mol=kwargs["rdkit_mol"]
    toprint=kwargs["toprint"]

    formats.message("Determining cat-pi interactions...",toprint=toprint)

    # Identify cations and atoms with aromatic bonds 
    pep_cat_atoms=[]
    pep_aro_atoms=[]
    hla_cat_atoms=[]
    hla_aro_atoms=[]
    # Get aromatics first
    numatoms_pep=pep_mol.GetNumAtoms()
    for i in range(numatoms_pep):
        a=pep_mol.GetAtomWithIdx(i)
        if a.GetIsAromatic():
            pep_aro_atoms.append(
                str(a.GetPDBResidueInfo().GetResidueNumber())+"_"+
                    a.GetPDBResidueInfo().GetChainId()+"_"+
                    str(a.GetIdx())
            )
    numatoms_hla=hla_mol.GetNumAtoms()
    for i in range(numatoms_hla):
        a=hla_mol.GetAtomWithIdx(i)
        if a.GetIsAromatic():
            hla_aro_atoms.append(
                str(a.GetPDBResidueInfo().GetResidueNumber())+"_"+
                    a.GetPDBResidueInfo().GetChainId()+"_"+
                    str(a.GetIdx())
            )

    # Next get positively ionizable atoms:
    for f in pep_feat:
        if f.GetFamily() == "PosIonizable":
            atom_indx=f.GetAtomIds()
            for i in atom_indx:
                pep_cat_atoms.append(
                    str(a.GetPDBResidueInfo().GetResidueNumber())+"_"+
                    a.GetPDBResidueInfo().GetChainId()+"_"+
                    str(a.GetIdx())
                )
    for f in hla_feat:
        if f.GetFamily() == "PosIonizable":
            atom_indx=f.GetAtomIds()
            for i in atom_indx:
                hla_cat_atoms.append(
                    str(a.GetPDBResidueInfo().GetResidueNumber())+"_"+
                    a.GetPDBResidueInfo().GetChainId()+"_"+
                    str(a.GetIdx())
                )

     # If user requests features summed for distance bins across the entire peptide, set a special flag that will tell us to add feature counts in distance bins across each residue and adjust the output dimensions accordingly.
    resnum_flag=False
    if resnum[0]=="all":
        resnum=[]
        [resnum.append(x.split("_")[0]) for x in all_atom_dist.columns.tolist() if x.split("_")[0] not in resnum]
        resnum_flag=True

    bin_num=int((bin_max-bin_min)/bin_size)
    catpi=[]
    picat=[]
    for r in resnum:
        pep_aro_idx=[x for x in pep_aro_atoms if str(r) in x]
        pep_cat_idx=[x for x in pep_cat_atoms if str(r) in x]

        # Retrieve inter-atomic distance for pi-cation and cation-pi pairings
        catpi_pairs=all_atom_dist.loc[
            hla_aro_atoms,
            pep_cat_idx    
        ]
        picat_pairs=all_atom_dist.loc[
            hla_cat_atoms,
            pep_aro_idx    
        ]

        # Now iterate through each bin and count the number of cation-pi and pi-cation pairings at each discretized distnace
        picat_tmp=[]
        catpi_tmp=[]
        for b in range(bin_num):
            picat_tmp.append(picat_pairs[
                (picat_pairs<b*bin_size+bin_size) &
                (picat_pairs>=b*bin_size)
                ].count().sum())
            catpi_tmp.append(catpi_pairs[
                (catpi_pairs<b*bin_size+bin_size) &
                (catpi_pairs>=b*bin_size)
                ].count().sum())
        
         # Keep a running sum of cat-pi/pi-cat pairs at each discretized distance rather than per-residue, if the user requested "pep" as the interface scope:
        if resnum_flag and catpi:
            catpi=[sum(x) for x in zip(catpi,catpi_tmp)]
            picat=[sum(x) for x in zip(picat,picat_tmp)]
        else:
            catpi.extend(catpi_tmp)
            picat.extend(picat_tmp)

    catpi_features=catpi+picat
    # Now generate our feature titles
    # Adjust the "resnum" vector to start from 1 and end at the number of residues
    resnum=[int(x)+1 for x in range(len(resnum))]
    if resnum_flag:
        feature_titles=[
            f"catpi_bin{x}" for x in range(bin_num)]+[
            f"picat_bin{x}" for x in range(bin_num)
        ]
    else:
        feature_titles=[
            f"catpi_res{x}_bin{y}" for x in resnum for y in range(bin_num)]+[
            f"picat_res{x}_bin{y}" for x in resnum for y in range(bin_num)
        ]
        
    # Output dataframe
    catpi_features=pd.DataFrame([catpi_features],columns=feature_titles)
    return catpi_features